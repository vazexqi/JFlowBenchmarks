package edu.illinois.jflow.benchmark;
import java.util.Random;

/**************************************************************************
 *                                                                         *
 *             Java Grande Forum Benchmark Suite - Version 2.0             *
 *                                                                         *
 *                            produced by                                  *
 *                                                                         *
 *                  Java Grande Benchmarking Project                       *
 *                                                                         *
 *                                at                                       *
 *                                                                         *
 *                Edinburgh Parallel Computing Centre                      *
 *                                                                         *
 *                email: epcc-javagrande@epcc.ed.ac.uk                     *
 *                                                                         *
 *      Original version of this code by Hon Yau (hwyau@epcc.ed.ac.uk)     *
 *                                                                         *
 *      This version copyright (c) The University of Edinburgh, 1999.      *
 *                         All rights reserved.                            *
 *                                                                         *
 **************************************************************************/

/**
 * Class representing the paths generated by the Monte Carlo engine.
 * 
 * <p>
 * To do list:
 * <ol>
 * <li><code>double[] pathDate</code> is not simulated.</li>
 * </ol>
 * 
 * @author H W Yau
 * @version $Revision: 1.1 $ $Date: 2010/07/23 03:44:00 $
 */
public class MonteCarloPath extends PathId {

    // ------------------------------------------------------------------------
    // Class variables.
    // ------------------------------------------------------------------------
    /**
     * Class variable for determining whether to switch on debug output or not.
     */
    public static boolean DEBUG = true;

    /**
     * Class variable for defining the debug message prompt.
     */
    protected static String prompt= "MonteCarloPath> ";

    /**
     * Class variable for determining which field in the stock data should be used. This is
     * currently set to point to the 'closing price', as defined in class RatePath.
     */
    public static int DATUMFIELD = 4;

    // ------------------------------------------------------------------------
    // Instance variables.
    // ------------------------------------------------------------------------
    /**
     * Random fluctuations generated as a series of random numbers with given distribution.
     */
    private double[] fluctuations;

    /**
     * The path values from which the random fluctuations are used to update.
     */
    private double[] pathValue;

    /**
     * Integer flag for determining how the return was calculated, when used to calculate the mean
     * drift and volatility parameters.
     */
    private int returnDefinition;

    /**
     * Value for the mean drift, for use in the generation of the random path.
     */
    private double expectedReturnRate;

    /**
     * Value for the volatility, for use in the generation of the random path.
     */
    private double volatility;

    /**
     * Number of time steps for which the simulation should act over.
     */
    private int nTimeSteps;

    /**
     * The starting value for of the security.
     */
    private double pathStartValue;

    // ------------------------------------------------------------------------
    // Constructors.
    // ------------------------------------------------------------------------
    /**
     * Default constructor. Needed by the HPT library to start create new instances of this class.
     * The instance variables for this should then be initialised with the
     * <code>setInitAllTasks()</code> method.
     */
    public MonteCarloPath() {
        super();
    }

    /**
     * Constructor, using the <code>ReturnPath</code> object to initialise the necessary instance
     * variables.
     * 
     * @param returnPath Object used to define the instance variables in this object.
     * @param nTimeSteps The number of time steps for which to generate the random path.
     * @exception DemoException Thrown if there is a problem initialising the object's instance
     *                variables.
     */
    public MonteCarloPath(ReturnPath returnPath, int nTimeSteps) {
        /**
         * These instance variables are members of PathId class.
         */
        copyInstanceVariables(returnPath);
        this.nTimeSteps= nTimeSteps;
        this.pathValue= new double[nTimeSteps];
        this.fluctuations= new double[nTimeSteps];
        /**
         * Whether to debug, and how.
         */
    }

    /**
     * Constructor, where the <code>PathId</code> objects is used to ease the number of instance
     * variables to pass in.
     * 
     * @param pathId Object used to define the identity of this Path.
     * @param returnDefinition How the statistic variables were defined, according to the
     *            definitions in <code>ReturnPath</code>'s two class variables
     *            <code>COMPOUNDED</code> and <code>NONCOMPOUNDED</code>.
     * @param expectedReturnRate The measured expected return rate for which to generate.
     * @param volatility The measured volatility for which to generate.
     * @param nTimeSteps The number of time steps for which to generate.
     * @exception DemoException Thrown if there is a problem initialising the object's instance
     *                variables.
     */
    public MonteCarloPath(PathId pathId, int returnDefinition, double expectedReturnRate,
            double volatility, int nTimeSteps) {
        /**
         * These instance variables are members of PathId class. Invoking with this particular
         * signature should point to the definition in the PathId class.
         */
        copyInstanceVariables(pathId);
        this.returnDefinition= returnDefinition;
        this.expectedReturnRate= expectedReturnRate;
        this.volatility= volatility;
        this.nTimeSteps= nTimeSteps;
        this.pathValue= new double[nTimeSteps];
        this.fluctuations= new double[nTimeSteps];
        /**
         * Whether to debug, and how.
         */
    }

    /**
     * Constructor, for when the user wishes to define each of the instance variables individually.
     * 
     * @param name The name of the security which this Monte Carlo path should represent.
     * @param startDate The date when the path starts, in 'YYYYMMDD' format.
     * @param endDate The date when the path ends, in 'YYYYMMDD' format.
     * @param dTime The interval in the data between successive data points in the generated path.
     * @param returnDefinition How the statistic variables were defined, according to the
     *            definitions in <code>ReturnPath</code>'s two class variables
     *            <code>COMPOUNDED</code> and <code>NONCOMPOUNDED</code>.
     * @param expectedReturnRate The measured mean drift for which to generate.
     * @param volatility The measured volatility for which to generate.
     * @param nTimeSteps The number of time steps for which to generate.
     */
    public MonteCarloPath(String name, int startDate, int endDate, double dTime,
            int returnDefinition, double expectedReturnRate, double volatility, int nTimeSteps) {
        /**
         * These instance variables are members of PathId class.
         */
        set_name(name);
        set_startDate(startDate);
        set_endDate(endDate);
        set_dTime(dTime);
        this.returnDefinition= returnDefinition;
        this.expectedReturnRate= expectedReturnRate;
        this.volatility= volatility;
        this.nTimeSteps= nTimeSteps;
        this.pathValue= new double[nTimeSteps];
        this.fluctuations= new double[nTimeSteps];
    }

    // ------------------------------------------------------------------------
    // Methods.
    // ------------------------------------------------------------------------
    // ------------------------------------------------------------------------
    // Accessor methods for class MonteCarloPath.
    // Generated by 'makeJavaAccessor.pl' script. HWY. 20th January 1999.
    // ------------------------------------------------------------------------
    /**
     * Accessor method for private instance variable <code>fluctuations</code>.
     * 
     * @return Value of instance variable <code>fluctuations</code>.
     * @exception DemoException thrown if instance variable <code>fluctuations</code> is undefined.
     */
    public double[] get_fluctuations() {
        if (this.fluctuations == null) {
            System.out.println("Variable fluctuations is undefined!-get_fluctuations");
            System.exit(0);
        }
        return (this.fluctuations);
    }

    /**
     * Set method for private instance variable <code>fluctuations</code>.
     * 
     * @param fluctuations the value to set for the instance variable <code>fluctuations</code>.
     */
    public void set_fluctuations(double[] fluctuations) {
        this.fluctuations= fluctuations;
    }

    /**
     * Accessor method for private instance variable <code>pathValue</code>.
     * 
     * @return Value of instance variable <code>pathValue</code>.
     * @exception DemoException thrown if instance variable <code>pathValue</code> is undefined.
     */
    public double[] get_pathValue() {
        if (this.pathValue == null) {
            System.out.println("Variable fluctuations is undefined!-get_pathValue");
            System.exit(0);
        }
        return (this.pathValue);
    }

    /**
     * Set method for private instance variable <code>pathValue</code>.
     * 
     * @param pathValue the value to set for the instance variable <code>pathValue</code>.
     */
    public void set_pathValue(double[] pathValue) {
        this.pathValue= pathValue;
    }

    /**
     * Accessor method for private instance variable <code>returnDefinition</code> .
     * 
     * @return Value of instance variable <code>returnDefinition</code>.
     * @exception DemoException thrown if instance variable <code>returnDefinition</code> is
     *                undefined.
     */
    public int get_returnDefinition() {
        if (this.returnDefinition == 0) {
            System.out.println("Variable fluctuations is undefined!-get_returnDefinition");
            System.exit(0);
        }
        return (this.returnDefinition);
    }

    /**
     * Set method for private instance variable <code>returnDefinition</code>.
     * 
     * @param returnDefinition the value to set for the instance variable
     *            <code>returnDefinition</code>.
     */
    public void set_returnDefinition(int returnDefinition) {
        this.returnDefinition= returnDefinition;
    }

    /**
     * Accessor method for private instance variable <code>expectedReturnRate</code>.
     * 
     * @return Value of instance variable <code>expectedReturnRate</code>.
     * @exception DemoException thrown if instance variable <code>expectedReturnRate</code> is
     *                undefined.
     */
    public double get_expectedReturnRate() {
        // if (this.expectedReturnRate == Double.NaN){
        // System.out.println("Variable expectedReturnRate is undefined!-get_expectedReturnRate");
        // System.exit(0);
        // }
        return (this.expectedReturnRate);
    }

    /**
     * Set method for private instance variable <code>expectedReturnRate</code>.
     * 
     * @param expectedReturnRate the value to set for the instance variable
     *            <code>expectedReturnRate</code>.
     */
    public void set_expectedReturnRate(double expectedReturnRate) {
        this.expectedReturnRate= expectedReturnRate;
    }

    /**
     * Accessor method for private instance variable <code>volatility</code>.
     * 
     * @return Value of instance variable <code>volatility</code>.
     * @exception DemoException thrown if instance variable <code>volatility</code> is undefined.
     */
    public double get_volatility() {
        // if (this.volatility == Double.NaN){
        // System.out.println("Variable volatility is undefined!-get_volatility");
        // }
        return (this.volatility);
    }

    /**
     * Set method for private instance variable <code>volatility</code>.
     * 
     * @param volatility the value to set for the instance variable <code>volatility</code> .
     */
    public void set_volatility(double volatility) {
        this.volatility= volatility;
    }

    /**
     * Accessor method for private instance variable <code>nTimeSteps</code>.
     * 
     * @return Value of instance variable <code>nTimeSteps</code>.
     * @exception DemoException thrown if instance variable <code>nTimeSteps</code> is undefined.
     */
    public int get_nTimeSteps() {
        if (this.nTimeSteps == 0) {
            System.out.println("Variable nTimeSteps is undefined!-get_nTimeSteps");
            System.exit(0);
        }
        return (this.nTimeSteps);
    }

    /**
     * Set method for private instance variable <code>nTimeSteps</code>.
     * 
     * @param nTimeSteps the value to set for the instance variable <code>nTimeSteps</code> .
     */
    public void set_nTimeSteps(int nTimeSteps) {
        this.nTimeSteps= nTimeSteps;
    }

    /**
     * Accessor method for private instance variable <code>pathStartValue</code>.
     * 
     * @return Value of instance variable <code>pathStartValue</code>.
     * @exception DemoException thrown if instance variable <code>pathStartValue</code> is
     *                undefined.
     */
    public double get_pathStartValue() {
        // if (this.pathStartValue == Double.NaN){
        // System.out.println("Variable pathStartValue is undefined!-get_pathStartValue");
        // System.exit(0);
        // }
        return (this.pathStartValue);
    }

    /**
     * Set method for private instance variable <code>pathStartValue</code>.
     * 
     * @param pathStartValue the value to set for the instance variable <code>pathStartValue</code>.
     */
    public void set_pathStartValue(double pathStartValue) {
        this.pathStartValue= pathStartValue;
    }

    // ------------------------------------------------------------------------
    /**
     * Method for copying the suitable instance variable from a <code>ReturnPath</code> object.
     * 
     * @param obj Object used to define the instance variables which should be carried over to this
     *            object.
     * @exception DemoException thrown if there is a problem accessing the instance variables from
     *                the target objetct.
     */
    private void copyInstanceVariables(ReturnPath obj) {
        //
        // Instance variables defined in the PathId object.
        set_name(obj.get_name());
        set_startDate(obj.get_startDate());
        set_endDate(obj.get_endDate());
        set_dTime(obj.get_dTime());
        //
        // Instance variables defined in this object.
        this.returnDefinition= obj.get_returnDefinition();
        this.expectedReturnRate= obj.get_expectedReturnRate();
        this.volatility= obj.get_volatility();
    }

    /**
     * Method for returning a RatePath object from the Monte Carlo data generated.
     * 
     * @return a <code>RatePath</code> object representing the generated data.
     * @exception DemoException thrown if there was a problem creating the RatePath object.
     */
    public RatePath getRatePath() {
        return (new RatePath(this));
    }

    /**
     * Method for calculating the sequence of fluctuations, based around a Gaussian distribution of
     * given mean and variance, as defined in this class' instance variables. Mapping from Gaussian
     * distribution of (0,1) to (mean-drift,volatility) is done via Ito's lemma on the log of the
     * stock price.
     * 
     * @param randomSeed The psuedo-random number seed value, to start off a given sequence of
     *            Gaussian fluctuations.
     * @exception DemoException thrown if there are any problems with the computation.
     */
    public void computeFluctuationsGaussian(long randomSeed) {
        if (nTimeSteps > fluctuations.length) {
            System.out
                    .println("Number of timesteps requested is greater than the allocated array!-computeFluctuationsGaussian");
            System.exit(0);
        }
        //
        // First, make use of the passed in seed value.
        Random rnd;
        if (randomSeed == -1) {
            rnd= new Random();
        } else {
            rnd= new Random(randomSeed);
        }
        //
        // Determine the mean and standard-deviation, from the mean-drift and
        // volatility.
        double mean= (expectedReturnRate - 0.5 * volatility * volatility) * get_dTime();
        double sd= volatility * Math.sqrt(get_dTime());
        double gauss, meanGauss= 0.0, variance= 0.0;
        for (int i= 0; i < nTimeSteps; i++) {
            gauss= rnd.nextGaussian();
            meanGauss+= gauss;
            variance+= (gauss * gauss);
            //
            // Now map this onto a general Gaussian of given mean and variance.
            fluctuations[i]= mean + sd * gauss;
            // dbgPrintln("gauss="+gauss+" fluctuations="+fluctuations[i]);
        }
        meanGauss/= (double)nTimeSteps;
        variance/= (double)nTimeSteps;
        // dbgPrintln("meanGauss="+meanGauss+" variance="+variance);
    }

    /**
     * Method for calculating the sequence of fluctuations, based around a Gaussian distribution of
     * given mean and variance, as defined in this class' instance variables. Mapping from Gaussian
     * distribution of (0,1) to (mean-drift,volatility) is done via Ito's lemma on the log of the
     * stock price. This overloaded method is for when the random seed should be decided by the
     * system.
     * 
     * @exception DemoException thrown if there are any problems with the computation.
     */
    public void computeFluctuationsGaussian() {
        computeFluctuationsGaussian((long)-1);
    }

    /**
     * Method for calculating the corresponding rate path, given the fluctuations and starting rate
     * value.
     * 
     * @param startValue the starting value of the rate path, to be updated with the precomputed
     *            fluctuations.
     * @exception DemoException thrown if there are any problems with the computation.
     */
    public void computePathValue(double startValue) {
        pathValue[0]= startValue;
        if (returnDefinition == 1 || returnDefinition == 2) {
            for (int i= 1; i < nTimeSteps; i++) {
                pathValue[i]= pathValue[i - 1] * Math.exp(fluctuations[i]);
            }
        } else {
            System.out.println("Unknown or undefined update method.-computePathValue");
            System.exit(0);
        }
    }
}
